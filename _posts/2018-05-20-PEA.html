---
layout: post
title: "Quantum Phase Estimation Algorithm and Hadamard test"
date: 2018-05-20
---
  <section>
<h1>Introduction</h1>
<p>Quantum Phase estimation is an important subroutine for quantum computing. Itâ€™s used for factoring, quantum simulation, and discrete logarithm . A version of Phase estimation called the Hadamard test is used to approximate the Jones polynomial (a significant expression in <a href = "https://en.wikipedia.org/wiki/Knot_theory">Knot theory</a>). Quantum computers can estimate phases more efficiently than classical computers because quantum computers can exploit the Quantum Fourier transform; which takes $O(n^2)$ gates on quantum computers instead of $O(n*2^n)$ on classical computers. This post will cover Phase Estimation and Hadamard test including their implementations on a quantum computer.</p> 
<section/>

  <section>
    $\newcommand{\ket}[1]{\left|{#1}\right\rangle}$
    
    <h2>Quantum Phase estimation</h2>
<p>The pure state of a two-level quantum system (qubit) is represented by a $2\times1$ matrix </p>

  </section>



  <section>
  <h2>Quantum Entanglement</h2>
  <p>The Controlled-NOT operator is applied to entangled systems. It flips the state of the second qubit if the state of the first qubit is 1 and leaves the second qubit unchanged if the first qubit is 0.

  \begin{align}
CNOT &= \begin{bmatrix}
  1 & 0 & 0 & 0 \\
  0 & 1 & 0 & 0 \\
  0 & 0 & 0 & 1 \\
  0 & 0 & 1 & 0 
\end{bmatrix}
  \end{align}
 The tensor product transforms a 2-level system into a 4-level system before applying the CNOT operator. 
\begin{align}
A \otimes B =  \begin{bmatrix}
    A_{11} \begin{bmatrix}
    b_{11} & b_{12} \\
    b_{21} & b_{22} \\
  \end{bmatrix} & A_{12} \begin{bmatrix}
    b_{11} & b_{12} \\
    b_{21} & b_{22} \\
  \end{bmatrix} \\
    A_{21} \begin{bmatrix}
    b_{11} & b_{12} \\
    b_{21} & b_{22} \\
  \end{bmatrix} & A_{22} \begin{bmatrix}
    b_{11} & b_{12} \\
    b_{21} & b_{22} \\
  \end{bmatrix}\\
  \end{bmatrix}
  \end{align}

 Entangling $\ket{1}$ with $\ket{0}$ and applying CNOT on the resulting state will flip the state of the second qubit.
\begin{align}
  \begin{bmatrix}
    0  \\
    1  \\
\end{bmatrix} \otimes \begin{bmatrix}
    1  \\
    0  \\
\end{bmatrix} = \begin{bmatrix}
    0  \\
  0 \\
  1 \\
  0\\
  \end{bmatrix} = \ket{10}
  \end{align}

  \begin{align}
CNOT\ket{10} =  \begin{bmatrix}
  1 & 0 & 0 & 0 \\
  0 & 1 & 0 & 0 \\
  0 & 0 & 0 & 1 \\
  0 & 0 & 1 & 0 
\end{bmatrix}. \begin{bmatrix}
    0  \\
  0 \\
  1 \\
  0\\
  \end{bmatrix} = \begin{bmatrix}
    0  \\
  0 \\
  0 \\
  1\\
  \end{bmatrix} = \ket{11}

  \end{align}</p>
  
  </section>



   <section>
  <h2>Superdense coding</h2>
  <p>Two bits of information can be encoded into one qubit. Superdense coding is performed by entangling two qubits and encoding two bits by applying an operator on one qubit. Entangled qubits are sent to the receiver who uses a decoder to read the bits that were encoded.

  Suppose the sender wants to send bits <i>01</i>. He will transform the first qubit into a superposition of states.

  
  
\begin{align} 
 \ket{\psi} =  H(\ket{0})= \frac{1}{\sqrt{2}} \ket{0} + \frac{1}{\sqrt{2}} \ket{1} \tag{0}
  
  \end{align}


  The sender will entangle this qubit with a second qubit that is spin down.

  \begin{align} 
 \ket{\psi} =  CNOT(\frac{1}{\sqrt{2}} \ket{0} + \frac{1}{\sqrt{2}} \ket{1} \otimes \ket{0}) = \frac{1}{\sqrt{2}} \ket{00} + \frac{1}{\sqrt{2}} \ket{11}\tag{1}
  \end{align}

  The X operator is applied on the first qubit.
   \begin{align} 
 \ket{\psi} =  X \otimes I (\frac{1}{\sqrt{2}} \ket{00} + \frac{1}{\sqrt{2}} \ket{11}) = \frac{1}{\sqrt{2}} \ket{01} + \frac{1}{\sqrt{2}} \ket{10}\tag{2}
  \end{align}

  The reciever will use the first and second qubit to decode <i>01</i> that was encoded in the first qubit.


   \begin{align} 
 \ket{\psi} =  CNOT(\frac{1}{\sqrt{2}} \ket{01} + \frac{1}{\sqrt{2}} \ket{10}) = \frac{1}{\sqrt{2}} \ket{01} + \frac{1}{\sqrt{2}} \ket{11}\tag{3}
  \end{align}


  \begin{align} 
  \ket{\psi} =  H \otimes I (\frac{1}{\sqrt{2}} \ket{01} + \frac{1}{\sqrt{2}} \ket{11}\tag{4})= \ket{01}
  
  \end{align}
  
The X operator is removed to encode <i>00</i>. The Z operator is applied in place of X to encode <i>10</i>. <i>11</i>
 is encoded with Z and X.</p>

 


  
   </section>

   <section>
     <h2>Simulation of superdense coding</h2>

    <p>It's not difficult to write a program simulates superdense coding. A program that consists of instructions we can run on a quantum computer is composed of commands where each line contains an operator and a qubit it's applied to. "H 1" means "Apply the Hadamard operator to qubit 1". A program that encodes and decodes bits <i>01</i> could be</p>

     <pre>
  <code>
   H 0
   CNOT 0 1
   X 0 
   CNOT 0 1
   H 0
   MEASURE 0
   MEASURE 1
  </code>
</pre>
  

   <p>Since we don't have access to a quantum computer, we can run this program on a <a href ="https://github.com/vtomole/qchackers/blob/master/software/eagle/vm.py"> virtual machine</a> that simulates a quantum computer.

   We paste the  <i>01</i> coding program into a <a href = " https://github.com/vtomole/qchackers/blob/master/software/eagle/sd_coding.eg"> file</a> and execute it on a virtual machine.</p>
     <pre>
  <code>
    python vm.py python vm.py sd_coding.eg

    MEASUREMENT of qubit 0 is 0 

    MEASUREMENT of qubit 1 is 1 

  </code>
    </pre>

				    
				    
   </section>


   <section>
<h2>Conclusion</h2>
<p>Superdense coding is a glimpse into the possibilities of quantum information. The principle of superposition and entanglement is used to encode two bits of information in one qubit. This technique can be executed on a quantum computer or a QVM.</p>
<section/>

 <section>
<h2>References</h2>
<ul>
  <li><a href = "https://en.wikipedia.org/wiki/Hadamard_test_(quantum_computation)">Wikipedia entry on Hadamard Test</a></li>
  <li><a href = "https://en.wikipedia.org/wiki/Quantum_phase_estimation_algorithm">Wikipedia entry Quantum phase estimation</a></li>
  <li><a href = "https://en.wikipedia.org/wiki/Quantum_Fourier_transform">Wikipedia entry on Quantum Fourier transform</a></li> 
  
</ul>
<section/>
