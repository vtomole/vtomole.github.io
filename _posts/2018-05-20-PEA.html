---
layout: post
title: "Quantum Phase Estimation Algorithm and Hadamard test"
date: 2018-05-20
---
  <section>
<h1>Introduction</h1>
<p>Quantum Phase estimation is an important subroutine for quantum computing. Itâ€™s used for factoring, quantum simulation, and discrete logarithm . A version of Phase estimation called the Hadamard test is used to approximate the Jones polynomial (a significant expression in <a href = "https://en.wikipedia.org/wiki/Knot_theory">Knot theory</a>). Quantum computers can estimate phases more efficiently than classical computers because quantum computers can exploit the Quantum Fourier transform; which takes $O(n^2)$ gates on quantum computers instead of $O(n*2^n)$ on classical computers. This post will cover Phase Estimation and Hadamard test including their implementations on a quantum computer.</p> 
<section/>

  <section>
$\newcommand\ket[1]{{|{#1}\rangle}}$
$\newcommand\bra[1]{{\langle{#1}|}}$
    
    <h2>Quantum Phase estimation</h2>
<p>The pure state of a two-level quantum system (qubit) is represented by a $2\times1$ matrix </p>

  </section>



  <section>
  <h2>Quantum Entanglement</h2>
  <p>The Controlled-NOT operator is applied to entangled systems. It flips the state of the second qubit if the state of the first qubit is 1 and leaves the second qubit unchanged if the first qubit is 0.

  \begin{align}
CNOT &= \begin{bmatrix}
  1 & 0 & 0 & 0 \\
  0 & 1 & 0 & 0 \\
  0 & 0 & 0 & 1 \\
  0 & 0 & 1 & 0 
\end{bmatrix}
  \end{align}
 The tensor product transforms a 2-level system into a 4-level system before applying the CNOT operator. 
\begin{align}
A \otimes B =  \begin{bmatrix}
    A_{11} \begin{bmatrix}
    b_{11} & b_{12} \\
    b_{21} & b_{22} \\
  \end{bmatrix} & A_{12} \begin{bmatrix}
    b_{11} & b_{12} \\
    b_{21} & b_{22} \\
  \end{bmatrix} \\
    A_{21} \begin{bmatrix}
    b_{11} & b_{12} \\
    b_{21} & b_{22} \\
  \end{bmatrix} & A_{22} \begin{bmatrix}
    b_{11} & b_{12} \\
    b_{21} & b_{22} \\
  \end{bmatrix}\\
  \end{bmatrix}
  \end{align}

 Entangling $\ket{1}$ with $\ket{0}$ and applying CNOT on the resulting state will flip the state of the second qubit.
\begin{align}
  \begin{bmatrix}
    0  \\
    1  \\
\end{bmatrix} \otimes \begin{bmatrix}
    1  \\
    0  \\
\end{bmatrix} = \begin{bmatrix}
    0  \\
  0 \\
  1 \\
  0\\
  \end{bmatrix} = \ket{10}
  \end{align}

  \begin{align}
CNOT\ket{10} =  \begin{bmatrix}
  1 & 0 & 0 & 0 \\
  0 & 1 & 0 & 0 \\
  0 & 0 & 0 & 1 \\
  0 & 0 & 1 & 0 
\end{bmatrix}. \begin{bmatrix}
    0  \\
  0 \\
  1 \\
  0\\
  \end{bmatrix} = \begin{bmatrix}
    0  \\
  0 \\
  0 \\
  1\\
  \end{bmatrix} = \ket{11}

  \end{align}</p>
  
  </section>



   <section>
   <h2>Hadamard Test</h2>
  <p>The Hadamard test solves: Given a Unitary $U$ and a state $\ket{\psi}$, estimate $\bra{\psi} | U \ket{\psi}$. It prepares the state  $\frac{1}{\sqrt{2}}(\ket{0} + \ket{1}) \ket{\psi}$ by appplying the hadamard gate to the first qubit,  applies cU from  $\frac{1}{\sqrt{2}}(\ket{0} + \ket{1})$ to $\ket{\psi} $ to get   $\frac{1}{\sqrt{2}}(\ket{0} \ket{\psi} + U \ket{1} \ket{\psi})$. After the hadamard gate is applied to the first qubit again, the probability of measuring $\ket{0}$ is \[\frac{1}{2} (1 + \text{Re} \bra{\psi} U \ket{\psi}) \] The probability of measuring $\ket{1}$ is

    \[\frac{1}{2} (1 - \text{Re} \bra{\psi} U \ket{\psi})\]

    The result we want to approximate is calculated by subtracting probabilities
    \[ \text{Re} \bra{\psi} U \ket{\psi} = \frac{1}{2} (1 + \text{Re} \bra{\psi} U \ket{\psi}) - \frac{1}{2} (1 - \text{Re} \bra{\psi} U \ket{\psi}) \]


    where $\text{Re} \bra{\psi} U \ket{\psi}$ is the real component of $\bra{\psi} U \ket{\psi}$. $\text{Im} \bra{\psi} | U \ket{\psi}$ is estimated by first preparing the state $\frac{1}{\sqrt{2}}(\ket{0} + i \ket{1})$ instead of $\frac{1}{\sqrt{2}}(\ket{0} + \ket{1})$.  This is prepared by applying the Hadamard gate followed by the S gate. The steps involved in deriving expected values are <a href = "https://en.wikipedia.org/wiki/Hadamard_test_(quantum_computation)">here</a> </p>

  <h3>Hadamard test example</h3>
  <p>Given a unitary 
$U = \begin{bmatrix}
    0 & 1 \\
    1 & 0 \\
    \end{bmatrix} $, and a state $\ket{1}$, estimate $\bra{1} | U \ket{1}$. $\bra{1} U \ket{1}$ = $\bra{1}\ket{0} = 0$.</p>

  <p> Encoding $\ket{1}$ is fulfilled by applying the X gate on the second qubit.
    $\ket{0} \text{X}(\ket{0}) = \ket{0} \ket{1}$. The Hadamard gate is applied to the first qubit  $H (\ket{0}) \ket{1}$ =  $\frac{1}{\sqrt{2}}(\ket{0} + \ket{1}) \ket{1}$. Applying CU to the system
    \[CU [\frac{1}{\sqrt{2}}(\ket{0} + \ket{1}) \ket{1}] = \frac{1}{\sqrt{2}}(\ket{0} \ket{1} + U \ket{1} \ket{1}) = \frac{1}{\sqrt{2}}(\ket{0} + U \ket{1}) \ket{1} = \frac{1}{\sqrt{2}}\ket{00} -\frac{1}{\sqrt{2}}\ket{11} \]

    Applying Hadamard to the first qubit results in:
    \[ H (\frac{1}{\sqrt{2}}\ket{00} -\frac{1}{\sqrt{2}}\ket{11}) = \frac{1}{2}\ket{00} - \frac{1}{2}\ket{01} + \frac{1}{2}\ket{10} + \frac{1}{2}\ket{11} \]

    This means there is a 0.5 probability qubit 1 is 0 and 0.5 that it's 1 upon measurement. 0.5 - 0.5 = 0, the expected value.
    

<h3>Hadamard test implementation on a Quantum computer</h3>
     <pre>
  <code>
 hadamard_test0 = Program(
    X(0),
    H(0),
    CNOT(0, 1),
    H(0),
)
print("Expected value will be closer to 0 than 100 or -100")
result = qvm.run_and_measure(hadamard_test0, [0], 100)
print(get_Re(result))
 
  </code>
     </pre>
     <p>The Hadamard test is probabilistic. It will give an expectation value that is close to 0 as is predicted by theory.</p>
      <p>What if $\ket{\psi}$ is $\frac{1}{\sqrt{2}}(\ket{0} + \ket{1})$ instead of $\ket{0}$? $\bra{\frac{1}{\sqrt{2}}(\ket{0} + \ket{1})} U \ket{\frac{1}{\sqrt{2}}(\ket{0} + \ket{1})} = \bra{\frac{1}{\sqrt{2}}(\ket{0} + \ket{1})}  \ket{\frac{1}{\sqrt{2}}(\ket{0} + \ket{1})} = 1 $. Implementing this program on a quantum computer shows that the answer is indeed 1.</p>
   <pre>
     <code>

 hadamard_test1 = Program(
    H(1),
    H(0),
    CNOT(0, 1),
    H(0),
)

print("Expected value will 1")
result = qvm.run_and_measure(hadamard_test1, [0], 1)
print(get_Re(result))
  </code>
   </pre>
   
Implementations of these Hadamard tests are <a href = "https://github.com/QCHackers/qchackers/blob/master/pyquil/hadamard_test.py">here</a>
  

				    
				    
   </section>


   <section>
<h2>Conclusion</h2>
<p>Finding the eigenvalues of an operator is an important problem in Linear algebra. Quantum Phase Estimation and it's cousin the Hadamard test are important subroutines for quantum algorithms that leverage the Quantum fourier transform to perform operations more efficiently on quantum computers than classical computers. Phase estimation can be used in quantum simulation and factoring. The Hadamard test is used to solve the Jones polynomial; which is important in knot and topological quantum field theories. This post covered examples of how the Hadamard test and Phase Estimation algorithm work.</p>
<section/>

 <section>
<h2>References</h2>
<ul>
  <li><a href = "https://en.wikipedia.org/wiki/Hadamard_test_(quantum_computation)">Wikipedia entry on Hadamard Test</a></li>
  <li><a href = "https://en.wikipedia.org/wiki/Quantum_phase_estimation_algorithm">Wikipedia entry Quantum phase estimation</a></li>
  <li><a href = "https://en.wikipedia.org/wiki/Quantum_Fourier_transform">Wikipedia entry on Quantum Fourier transform</a></li> 
  
</ul>
<section/>
